import type { Wish } from "Wish"
import { fulfill } from "Wish"
import { fromList, get } from "Dictionary"
import { fromMaybe } from "Maybe"
import {} from "Number"


#-
import { attributesModule, h, init, propsModule, eventListenersModule } from "snabbdom"

const AppEnv = {
  patch: null,
  currentElement: null,
  currentState: null,
  rootView: null,
  onUrlChangedAction: null,
}
-#

export type Element = Element

// https://keycode.info/
export type Key
  = KEY_ENTER
  | KEY_BACKSPACE
  | KEY_ANY
  | KEY_A
  | KEY_B
  | KEY_C
  | KEY_D
  | KEY_E
  | KEY_F
  | KEY_G
  | KEY_H
  | KEY_I
  | KEY_J
  | KEY_K
  | KEY_L
  | KEY_M
  | KEY_N
  | KEY_O
  | KEY_P
  | KEY_Q
  | KEY_R
  | KEY_S
  | KEY_T
  | KEY_U
  | KEY_V
  | KEY_W
  | KEY_X
  | KEY_Y
  | KEY_Z

KEY_CODE_MAPPINGS = fromList([
  <13, KEY_ENTER>,
  <8, KEY_BACKSPACE>,
  <65, KEY_A>,
  <66, KEY_B>,
  <67, KEY_C>,
  <68, KEY_D>,
  <69, KEY_E>,
  <70, KEY_F>,
  <71, KEY_G>,
  <72, KEY_H>,
  <73, KEY_I>,
  <74, KEY_J>,
  <75, KEY_K>,
  <76, KEY_L>,
  <77, KEY_M>,
  <78, KEY_N>,
  <79, KEY_O>,
  <80, KEY_P>,
  <81, KEY_Q>,
  <82, KEY_R>,
  <83, KEY_S>,
  <84, KEY_T>,
  <85, KEY_U>,
  <86, KEY_V>,
  <87, KEY_W>,
  <88, KEY_X>,
  <89, KEY_Y>,
  <90, KEY_Z>,
])

getKeyFromCode :: Number -> Key
getKeyFromCode = (keyCode) => fromMaybe(KEY_ANY, get(keyCode, KEY_CODE_MAPPINGS))

export type Event
  = AbstractEvent({ eventType :: String })
  | ClickEvent({ eventType :: String })
  | InputEvent({
      eventType :: String,
      target :: { value :: String },
      data :: String,
      inputType :: String, // Make an InputType type for it
    })
  | KeyboardEvent({
      eventType :: String,
      key :: Key,
      altKey :: Boolean,
      ctrlKey :: Boolean,
      shiftKey :: Boolean,
    })
  | UrlEvent({ url :: String })

// https://www.w3schools.com/jsref/obj_keyboardevent.asp
buildKeyboardEvent = (e) => {
  k = getKeyFromCode(e.keyCode)

  return KeyboardEvent({
    eventType: e.eventType,
    key: k,
    altKey: e.altKey,
    ctrlKey: e.ctrlKey,
    shiftKey: e.shiftKey,
  })
}

buildInputEvent = (e) => ({
  eventType: e.eventType,
  target: e.target,
  data: e.data,
  inputType: e.inputType,
})

#-
const EventConstructors = Object.freeze({
  mouseout: AbstractEvent,
  mouseover: AbstractEvent,
  change: AbstractEvent,
  click: ClickEvent,
  input: buildInputEvent,
  keypress: buildKeyboardEvent,
  keydown: buildKeyboardEvent,
  keyup: buildKeyboardEvent,
  transitionend: AbstractEvent,
})
-#



export alias Action a = a -> Event -> List (Wish (a -> a) (a -> a))
export alias Subscription a = ((a -> a) -> ()) -> ()


export type Attribute
  = AttributeId(String)
  | AttributeClass(String)
  | AttributeValue(String)
  | AttributePlaceholder(String)
  | AttributeType(String)
  | AttributeKey(String)
  | AttributeHref(String)
  | AttributeSrc(String)
  | AttributeTitle(String)
  | AttributeAlt(String)
  | AttributeTo(String)
  | AttributeOnClick(Action a)
  | AttributeOnMouseOver(Action a)
  | AttributeOnMouseOut(Action a)
  | AttributeOnChange(Action a)
  | AttributeOnInput(Action a)
  | AttributeOnKeyPress(Action a)
  | AttributeOnKeyDown(Action a)
  | AttributeOnKeyUp(Action a)
  | AttributeOnTransitionEnd(Action a)


#-
const getCurrentState = () => AppEnv.currentState

const runAction = updater => {
  AppEnv.currentState = updater(getCurrentState())
  const newElement = AppEnv.rootView(AppEnv.currentState)
  AppEnv.patch(AppEnv.currentElement, newElement)
  AppEnv.currentElement = newElement
}

const wrapEventHandler = (ctor, handler) => {
  return event => {
    event.eventType = event.type
    // So now calling an event handler gives us a list of wishes
    const wishes = handler(AppEnv.currentState)(ctor(event))
    wishes.forEach(fulfill(runAction)(runAction))
  }
}

const getAttributeTuple = attr =>
  [attr.__constructor.substr(9).toLowerCase(), attr.__args[0]]

const ATTR_NAMES = [
  "id",
  "class",
  "placeholder",
  "type",
  "href",
  "src",
  "alt",
  "title"
]
const PROP_NAMES = [
  "value"
]

const objectifyAttrs = attrs => attrs.reduce((obj, attr) => {
  const [attrName, attrValue] = getAttributeTuple(attr)
  if (attrName === "key") {
    return { ...obj, key: attrValue }
  } else if (ATTR_NAMES.includes(attrName)) {
    return { ...obj, attrs: { ...obj.attrs, [attrName]: attrValue }}
  } else if (PROP_NAMES.includes(attrName)) {
    return { ...obj, props: { ...obj.props, [attrName]: attrValue }}
  } else if (attrName.substr(0, 2) === "on") {
    const eventName = attrName.substr(2)
    const ctor = EventConstructors[eventName]
    return { ...obj, on: { ...obj.on, [eventName]: wrapEventHandler(ctor, attrValue) }}
  } else {
    return { ...obj, [attrName]: attrValue };
  }
}, {})
-#


id :: String -> Attribute
export id = AttributeId

className :: String -> Attribute
export className = AttributeClass

key :: String -> Attribute
export key = AttributeKey

value :: String -> Attribute
export value = AttributeValue

placeholder :: String -> Attribute
export placeholder = AttributePlaceholder

inputType :: String -> Attribute
export inputType = AttributeType

to :: String -> Attribute
export to = AttributeTo

href :: String -> Attribute
export href = AttributeHref

src :: String -> Attribute
export src = AttributeSrc

title :: String -> Attribute
export title = AttributeTitle

alt :: String -> Attribute
export alt = AttributeAlt

onClick :: (Action a) -> Attribute
export onClick = AttributeOnClick

onMouseOver :: (Action a) -> Attribute
export onMouseOver = AttributeOnMouseOver

onMouseOut :: (Action a) -> Attribute
export onMouseOut = AttributeOnMouseOut

onChange :: (Action a) -> Attribute
export onChange = AttributeOnChange

onInput :: (Action a) -> Attribute
export onInput = AttributeOnInput

onKeyPress :: Action a -> Attribute
export onKeyPress = AttributeOnKeyPress

onKeyDown :: Action a -> Attribute
export onKeyDown = AttributeOnKeyDown

onKeyUp :: Action a -> Attribute
export onKeyUp = AttributeOnKeyUp

onTransitionEnd :: Action a -> Attribute
export onTransitionEnd = AttributeOnTransitionEnd

text :: String -> Element
export text = (content) => #- content -#



interface JSXChildren a {
  toElement :: a -> Element
}

instance JSXChildren Element {
  toElement = (x) => x
}

instance JSXChildren String {
  toElement = text
}

instance JSXChildren () {
  toElement = (_) => #- null -#
}


tag :: JSXChildren a => String -> List Attribute -> List a -> Element
export tag = (tagName, attrs, children) => #- {
  return h(tagName, objectifyAttrs(attrs), children)
} -#


// TAGS - start

export a = tag("a")
export article = tag("article")
export aside = tag("aside")
export audio = tag("audio")
export blockquote = tag("blockquote")
export br = tag("br")
export button = tag("button")
export canvas = tag("canvas")
export code = tag("code")
export datalist = tag("datalist")
export details = tag("details")
export div = tag("div")
export embed = tag("embed")
export figure = tag("figure")
export footer = tag("footer")
export form = tag("form")
export h1 = tag("h1")
export h2 = tag("h2")
export h3 = tag("h3")
export h4 = tag("h4")
export h5 = tag("h5")
export h6 = tag("h6")
export header = tag("header")
export hgroup = tag("hgroup")
export i = tag("em")
export img = tag("img")
export input = tag("input")
export li = tag("li")
export main = tag("main")
export mark = tag("mark")
export nav = tag("nav")
export ol = tag("ol")
export option = tag("option")
export output = tag("output")
export p = tag("p")
export progress = tag("progress")
export ruby = tag("ruby")
export section = tag("section")
export span = tag("span")
export strong = tag("strong")
export time = tag("time")
export ul = tag("ul")
export video = tag("video")
export wbr = tag("wbr")

// TAGS - end

empty :: JSXChildren a => List Attribute -> List a -> Element
export empty = (attrs, children) => #- null -#

link :: JSXChildren a => List Attribute -> List a -> Element
export link = (attrs, children) => #-{
  const objAttrs = objectifyAttrs(attrs);
  if (objAttrs.to) {
    if (!objAttrs.attrs) {
      objAttrs.attrs = {}
    }
    objAttrs.attrs.href = `\#${objAttrs.to}`
  }

  return h("a", { ...objAttrs }, children);
}-#


onUrlChanged :: Action a -> ()
export onUrlChanged = (action) => #-{
  AppEnv.onUrlChangedAction = action

  window.onpopstate = function(event) {
    const path = document.location.hash.substr(1) || "/";
    const wishes = AppEnv.onUrlChangedAction(getCurrentState())(UrlEvent({ url: path }))
    wishes.forEach(fulfill(runAction)(runAction))
  }
}-#

getUrl :: () -> String
export getUrl = (_) => #- document.location.hash.substr(1) || "/" -#


syncAction :: (a -> Event -> a) -> Action a
export syncAction = (stateUpdate) => (
  (state, event) => [of((_) => stateUpdate(state, event))]
)


/**
 * render - boostraps the app and takes a component, and an initial state as parameters
 */
render :: (a -> Element) -> a -> String -> ()
export render = (view, initialState, containerId) => {
  initialElement = view(initialState)
  #-
  const patch = init([attributesModule, propsModule, eventListenersModule])
  patch(document.getElementById(containerId), initialElement)

  AppEnv.patch = patch
  AppEnv.currentElement = initialElement
  AppEnv.rootView = view
  AppEnv.currentState = initialState
  -#

  return ()
}

renderWithSubscriptions :: (a -> Element) -> a -> List (Subscription a) -> String -> ()
export renderWithSubscriptions = (view, initialState, subscriptions, containerId) => {
  render(view, initialState, containerId)

  #- subscriptions.forEach(sub => sub(runAction)) -#

  return ()
}
