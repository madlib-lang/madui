import { get } from "Dictionary"
import {} from "Number"

import type { Config } from "@/Config"
import type { Element } from "@/Element"
import { DEFAULT_CONFIG } from "@/Config"

import { runAction, wrapEventHandler } from "@/CoreUtils"
import { EventConstructors } from "@/Event"

#-
import {
  attributesModule,
  init,
  propsModule,
  eventListenersModule,
  styleModule
} from "snabbdom"
-#



getUrl :: a -> String
export getUrl = () => #- document.location.href || "" -#



#-
const startGlobalEventHandlers = (env, globalActions) => {
  const keysForWindowEvents = [];
  while (globalActions !== null) {
    keysForWindowEvents.push(({
      eventName: globalActions.v.__args[0],
      eventHandler: globalActions.v.__args[1],
    }))
    globalActions = globalActions.n
  }

  keysForWindowEvents.forEach(ga => {
    const handler = wrapEventHandler(env, EventConstructors[ga.eventName], ga.eventHandler)
    window.addEventListener(ga.eventName, handler)

    if (ga.eventName === "popstate") {
      handler({})
    }
  })
}
-#


#-
const hashFixModule = () => {
  let triggered = false
  history.scrollRestoration = "manual"
  return {
    post: () => {
      if (!triggered) {
        const element = document.getElementById(window.location.hash.substr(1))
        if (element) {
          const top = element.offsetTop
          window.scrollTo(0, top)
        }
      }
      triggered = true
    },
  }
}
-#

renderWithConfig :: Config a -> (a -> Element a) -> a -> String -> {}
export renderWithConfig = (config, view, initialState, containerId) => {
  #-
  window.env = {
    routingKind: config.routingKind.__constructor,
    patch: null,
    currentElement: null,
    currentState: null,
    rootView: null,
  }
  -#
  initialElement = view(initialState)
  #-
  const patch = init([attributesModule, propsModule, eventListenersModule, styleModule, hashFixModule()])
  patch(document.getElementById(containerId), initialElement)

  window.env.patch = patch
  window.env.currentElement = initialElement
  window.env.rootView = view
  window.env.currentState = initialState

  startGlobalEventHandlers(window.env, config.globalEventHandlers)
  // needed to make the router work
  window.addEventListener("popstate", () => { runAction(window.env)(x => x) })

  let subs = config.subscriptions
  while (subs !== null) {
    subs.v(runAction(window.env))
    subs = subs.n
  }
  -#

  return {}
}

/**
 * render - boostraps the app and takes a component, and an initial state as parameters
 */
 render :: (a -> Element a) -> a -> String -> {}
 export render = renderWithConfig(DEFAULT_CONFIG)
